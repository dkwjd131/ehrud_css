# 1. 엘리먼트 가계도
* 태그 안에 태그를 입력하면 태그가 중첩되었다고 말한다. <br>

* 바깥쪽 태그를 부모, 안쪽 태그를 자식이라고 하며 같은 부모 아래에 있는 태그를 형제라고 한다.<br>

* 자식 엘리먼트는 종종 부모 스타일을 상속한다.

<br><br>

# 2. 문맥에 따른 스타일 정의
* 문맥 스타일을 사용하면 부모 및 형제를 기준으로 특정 엘리먼트가 보이는 방식을 지정할 수 있다. <br>

* 공백으로 부모와 자손을 구별하며, 자손 선택자는 부모의 자손이 될 때만 스타일을 적용 받는다.<br><br>

* 구문<br>
1) *a b c {color : red;}* <br>
b가 a의 자손이고 c가 b의 자손일 때, c의 색상을 붉은색으로 적용한다. <br>

2) *a * c {color : red;}* <br>
c가 c의 부모와 상관없이 a 내에 속할 때, c의 색상을 붉은색으로 적용한다. <br>

3) *a > c {color : red;}* <br>
c가 a의 직계 자손일 때, c의 색상을 붉은색으로 적용한다. <br>

4) *a + c {color : red;}* <br>
형제 c가 a 바로 다음에 나올 때, c의 색상을 붉은색으로 적용한다. <br>

5) *a ~ c {color : red;}* <br>
형제 c가 a 다음 어디에든 나올 때, c의 색상을 붉은색으로 적용한다. <br>


<br><br>

# 3. 의사 클래스
* 의사 클래스는 엘리먼트의 기본 상태 외에 링크 방문 상태, (링크에 마우스를 올려 놓은) 호버 상태 등 특수한 상태에 별도로 스타일을 적용할 수 있다. <br>

<br><br>

## 3.1 링크 및 동적 의사 클래스 [04_01_실습]
[링크 의사 클래스]

* 앵커 \<a> 태그의 기본 상태 외에, 링크 방문 후 상태와 호버 상태 등의 시점에 스타일을 적용 한다. <br>

* 앵커 \<a> 태그의 기본 상태 스타일을 먼저 적용하는 것이 좋다. <br>

[동적 의사 클래스]
* 모든 엘리먼트의 클릭 상태와 호버 상태 등의 시점에 스타일을 적용 한다. <br>

* 엘리먼트의 기본 상태 스타일을 먼저 적용하는 것이 좋다. <br>

<br><br>

[각 상태 별 스타일]
    <br> **아래의 순서로 지정하지 않으면 정상적으로 작동하지 않을 수도 있다.**<br>
<br>
1) **:link** (링크 클래스) <br>
아직 선택하지 않은, href 값이 히스토리에 없는 하이퍼텍스트 링크의 모습을 선언 <br>
visted 의사 클래스 보다 항상 먼저 선언되어야 한다. <br>
*a:link { ... }*<br>

2) **:visited** (링크 클래스) <br>
이미 선택한, href 값이 히스토리에 있는 하이퍼텍스트 링크의 모습을 선언 <br>
*a:vistied { ... }*<br>

3) **:hover** (동적 클래스) <br>
마우스 포인터가 링크 위에 올라올 때 모습을 선언 <br>
마우스 상호작용 엘리먼트에만 적용 <br>
*a:hover { ... }*<br>

4) **:focus** (동적 클래스) <br>
텍스트 필드, 입력칸 처럼 포커스를 받을 수 있는 엘리먼트에 적용<br>
요소를 클릭한 상태이거나 클릭한 상태에 적용 <br>
*a:focus { ... }*<br>

5) **:active** (동적 클래스) <br>
사용자가 클릭하고 있는 순간의 모습을 선언 <br>
*a:active { ... }*<br>


<br><br>

## 3.3 구조적 및 기타 의사 클래스 [04_02_실습]
[구조적 의사 클래스]

* 부모와 각 자식 엘리트먼트 별 개별 스타일을 적용한다. <br>

* 엘리먼트에 적용된 스타일은 자식 엘리먼트에 상속된다. <br>

* 하나의 엘리먼트에 스타일이 중복되어 선언되면, 코드 상 마지막으로 선언된 스타일이 적용된다. <br>

[기타 의사 클래스]

* 언어 또는 태그 해당 여부를 기준으로 엘리먼트에 스타일을 적용한다.<br>


<br>

[각 상태 별 스타일]
<br>

1) **:root** (구조적 클래스)<br>
문서의 최상위 엘리먼트에 선언 <br>
*a:root { ... }*<br>

2) **:empty** (구조적 클래스)<br>
자식이 없는 엘리먼트에 선언 <br>
*a:empty { ... }*<br>

3) **:only-child** (구조적 클래스)<br>
형제가 없는 외동 자식 엘리먼트에 선언 <br>
*a:only-child { ... }*<br>

4) **:only-of-type** (구조적 클래스)<br>
해당 선택자 중에서 형제가 없는 외동 자식 엘리먼트에 선언 <br>
*a:only-child { ... }*<br>

5) **:first-child** (구조적 클래스) <br>
첫번째 자식에 해당되는 엘리먼트에 선언 <br>
*a:first-child { ... }*<br>

6) **:first-of-type** (구조적 클래스) <br>
해당 선택자 중에서 처음으로 해당 선택자에 속하는 엘리먼트에 선언 <br>
*a:first-of-type { ... }*<br>

7) **:nth-child(#)** (구조적 클래스) <br>
지정된 순서에 해당하는 자식 엘리먼트에 선언 <br>
*a:nth-child(3) { ... }*<br>

8) **:nth-of-type(#)** (구조적 클래스) <br>
해당 선택자 중에서 지정된 순서에 해당하는 엘리먼트에 선언 <br>
*a:nth-of-type(3) { ... }*<br>

9) **:nth-last-of-type(#)** (구조적 클래스) <br>
해당 선택자 중에서 밑에서 부터 지정된 순서에 해당하는 엘리먼트에 선언<br>
*a:nth-last-of-type(3) { ... }*<br>

10) **:last-child** (구조적 클래스) <br>
마지막 자식에 해당되는 엘리먼트에 선언<br>
*a:last-child { ... }*<br>

11) **:last-of-type** (구조적 클래스) <br>
해당 선택자 중에서 마지막으로 해당 선택자에 속하는 엘리먼트에 선언<br>
*a:last-of-type { ... }*<br>

12) **:lang()** (기타 클래스)<br>
언어 코드를 기반으로 스타일 적용<br>
*a:lang(fr) { ... }*<br>

12) **:not()** (기타 클래스)<br>
특정 선택자를 스타일 적용에서 제외<br>
*a:not(.dialog) { ... }* (클래스가 dialog 인 엘리먼트 제외)<br>

<br><br>


# 4. 의사 엘리먼트
* 의사 엘리먼트는 엘리먼트의 나머지 부분과 상관없이 독립적으로 스타일을 적용할 수 있는 단락의 첫 글자 또는 첫 줄 같은 특정 영역을 말한다.

<br>

## 4.1 첫 글자, 첫 줄 의사 엘리먼트
* 콜론을 한 개 또는 두 개 사용할 수도 있다. <br><br>
[각 상태 별 스타일] <br>

    1) **:first-letter** <br>
    텍스트의 첫 글자에 선언 <br>
    *a:first-letter { ... }*<br>

    2) **:first-line** <br>
    텍스트의 처 줄에 선언 <br>
    *a:first-line { ... }*<br>

    3) **혼합 사용** <br>
    *article p : first-of-type :: first-letter {color : yellow;}* <br>
    article의 자식 p 태그 중 첫 번째 엘리먼트의 첫 번째 글자를 노란색으로 적용

<br><br>

## 4.2 엘리먼트 전, 후 콘텐츠 설정
* 선택자 위, 아래에 보여줄 콘텐츠를 생성할 때 사용한다.<br>

* 보통 content 속성과 함께 사용하며, 보여줄 스타일을 정의한다. <br>

* 이미지 컨텐츠를 추가한다면, 페이지에 이미지가 보여지지만 HTML 코드상에는 나오지 않는다. <br>

* 적용할 엘리먼트의 기본 상태를 미리 정의하는 것이 좋다. <br><br>
[각 상태 별 스타일] <br>

    1) **:before** <br>
    엘리먼트 앞에 콘텐츠 추가 선언 <br>
    *a:before { content : ... }*<br>

    2) **:after** <br>
    엘리먼트 뒤에 콘텐츠 추가 선언<br>
    *a:after { content : ... }*<br>

<br><br>

# 5. 태그 어트리뷰트(속성) 기반 스타일 정의
* 엘리먼트가 특정 속성을 가질 경우 스타일을 설정한다.

* attr 값은 대소문자를 구별한다.

<br>

[각 상태 별 스타일] <br>

1) **[attr]** <br>
a 태그의 지정한 attr를 갖는 엘리먼트 선언 <br>
*a[attr] { ... }*<br>
    
2) **[attr = "value"]** <br>
a 태그의 지정한 attr가 "value"와 정확히 일치하는 값을 갖는 엘리먼트 선언 <br>
*a[attr = "value"] { ... }*<br>

3) **[attr~ = "value"]** <br>
a 태그의 지정한 attr가 공백으로 구분한 목록 내의 값이 "value"와 정확히 일치하는 값을 갖는 엘리먼트 선언 <br>
*a[attr~ = "value"] { ... }*<br>

4) **[attr| = "value"]** <br>
a 태그의 지정한 attr가 | 으로 구분한 목록 내의 값이 "value"와 정확히 일치하는 값을 갖는 엘리먼트 선언 <br>
*a[attr| = "value"] { ... }*<br>

5) **[attr^ = "value"]** <br>
a 태그의 지정한 attr가 "value"로 시작하는 엘리먼트 선언 <br>
*a[attr^ = "value"] { ... }*<br>

6) **[attr$ = "value"]** <br>
a 태그의 지정한 attr의 끝 값이 "value"인 엘리먼트 선언 <br>
*a[attr$= "value"] { ... }*<br>

7) **[attr* = "value"]** <br>
a 태그의 지정한 attr의 일부 값이 "value"와 일치하는 엘리먼트 선언 <br>
*a[attr\* = "value"] { ... }*<br>

<br><br>

# 6. 미디어 쿼리
* 특정 미디어 타입에 따라 스타일을 지정 <br>

* 미디어 적용 대상과 스타일을 적용할 CSS 파일을 href에 선언 한다. <br>

* link 태그나 style 태그 등에 사용할 수 있다. <br>

<br>

## 6.1 미디어 적용 대상
1) screen : 컴퓨터 디스플레이

2) tty : 텔레타이프, 컴퓨터 터미널, 오래된 휴대용 기기

3) tv : 텔레비전 디스플레이

4) projection : 프로젝션

5) handheld : 휴대용 전화기 및 PDA

6) print : 종이

7) braille : 점자 리더기

8) speech : 음성 신디사이저

9) all : 모든 기기

<br><br>

## 6.2 미디어 쿼리 속성
* 미디어 쿼리를 여러 개 지정하려면 and를 사용한다. <br>

1) aspect-ratio

2) ...

3) min-width

<br><br>

## 6.3 미디어 쿼리 일반 구문

EX )

*\<link media = " screen and (min-width : 600 px) and (max-width : 980 px) href = "iphon.css">* <br>

* 아이폰 화면에서 보여질 때의 화면 크기와 적용한 CSS 파일

<br><br>

## 6.4 스타일 시트에 미디어 쿼리 임베드 [04_04_실습]
* @media 규칙을 사용하면 스타일 시트 파일에 미디어 쿼리를 직접 임베드할 수 있다. <br><br>

    [ @media 쿼리 구문 ]

    *@media screen and (max-device-width : 480 px) and (min-device-width : 320 px)* <br>
    
* 문서 헤드에 @media 쿼리 구문을 입력한다. 추가 규칙을 추가할 수도 있으며, @ 규칙에 속하지 않은 규칙은 항상 @ 규칙 다음에 위치해야 한다.

<br><br>

# 7. 부모로부터의 속성 상속
* 자식과 자손 HTML 태그는 보통 부모의 스타일을 전제(상속) 한다. <br>

* 이를 **스타일 상속**이라 한다. <br>

* 예외적으로 마진, 너비, 보더 등 부모로부터 스타일 속성을 **상속받지 않는** 속성 또한 존재한다.

<br><br>

## 7.1 상속 재정의
* inherit : 일반적으로 상속되지 않는 속성을 상속하게 하거나 적용된 스타일 값을 재정의하고 부모의 값을 상속하게 한다. <br>

* none : 보더, 이미지, 기타 시각적인 엘리먼트를 감춘다.<br>

* normal : 아무런 스타일도 적용되지 않게 한다. <br>

* auto : 브라우저가 상황에 따라 엘리먼트를 어떻게 보여줄지 결정하게 된다.

<br><br>

## 7.2 !important 선언
* !important 선언을 추가하면 캐스케이딩 순서를 결정할 때 특정 속성-값 선언에 가장 높은 우선순위를 부여하여, 현재 적용된 다른 규칙과 상관없이 강제로 스타일이 적용된다.<br>

* 예를 들어 h1에 대한 선언 2개가 있을 때, 첫번째 선언의 color 속성에 !important 를 지정하면 두번째 선언의 color 속성은 무시된다. <br>

* 다른 선언들 또한 추가할 수 있으며 !important 으로 지정하거나 지정하지 않을 수도 있다.<br>

    [ !important 선언 구문 ]<br>
    h1 { color : red !important; font-size : 2em; }

<br><br>

# 8. 캐스케이딩 순서의 판단
* 캐스케이딩 순서는 페이지 상단부터 시작해 아래로 내려오며 적용되는 스타일 순서를 의미한다. 보통은 가장 나중에 정의한 스타일이 사용된다. <br>

<br><br>

## 8.1 엘리먼트의 캐스케이딩 우선순위 판단
* 아래 캐스케이딩 순서 기준에 따라 어떤 스타일이 적용될지 판단한다. 상위에 있는 기준이 우선순위가 더 높다. <br>
<br>

1. 사용자 스타일 <br>
    사용자가 자신의 기본 스타일 시트를 지정한다.

2. 인라인 스타일 <br>
    인라인 스타일은 다른 사항들보다 우선적으로 스타일이 적용된다.

3. 미디어 타입 <br>
    스타일에 대해 미디어 타입을 설정하고, 해당 미디어 타입의 엘리먼트가 보이지 않으면 스타일이 사용되지 않는다.

4. 중요도 <br>
    만약 페이지 작성자와 사용자 모두 !important 를 사용했다면 사용자가 지정한 선언이 적용된다.

5. 구체성 <br>
    규칙이 문맥 의존적일 수록 캐스케이딩 순서도 높아진다.<br>
    EX) #copy p b { ~ }가 b { ~ } 보다 우선순위가 높다.

6. 순서 <br>
    현 단계까지도 같은 우선순위가 존재할 경우 마지막에 나열한 규칙에 우선순위를 부여한다.

7. 부모로부터 상속한 스타일 <br>

8. 브라우저 기본 스타일