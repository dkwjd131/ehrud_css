# 1. 엘리먼트 가계도
* 태그 안에 태그를 입력하면 태그가 중첩되었다고 말한다. <br>

* 바깥쪽 태그를 부모, 안쪽 태그를 자식이라고 하며 같은 부모 아래에 있는 태그를 형제라고 한다.<br>

* 자식 엘리먼트는 종종 부모 스타일을 상속한다.

<br><br>

# 2. 문맥에 따른 스타일 정의
* 문맥 스타일을 사용하면 부모 및 형제를 기준으로 특정 엘리먼트가 보이는 방식을 지정할 수 있다. <br>

* 공백으로 부모와 자손을 구별하며, 자손 선택자는 부모의 자손이 될 때만 스타일을 적용 받는다.<br><br>

* 구문<br>
1) *a b c {color : red;}* <br>
b가 a의 자손이고 c가 b의 자손일 때, c의 색상을 붉은색으로 적용한다. <br>

2) *a * c {color : red;}* <br>
c가 c의 부모와 상관없이 a 내에 속할 때, c의 색상을 붉은색으로 적용한다. <br>

3) *a > c {color : red;}* <br>
c가 a의 직계 자손일 때, c의 색상을 붉은색으로 적용한다. <br>

4) *a + c {color : red;}* <br>
형제 c가 a 바로 다음에 나올 때, c의 색상을 붉은색으로 적용한다. <br>

5) *a ~ c {color : red;}* <br>
형제 c가 a 다음 어디에든 나올 때, c의 색상을 붉은색으로 적용한다. <br>


<br><br>

# 3. 의사 클래스
* 의사 클래스는 엘리먼트의 기본 상태 외에 링크 방문 상태, (링크에 마우스를 올려 놓은) 호버 상태 등 특수한 상태에 별도로 스타일을 적용할 수 있다. <br>

<br><br>

## 3.1 링크 및 동적 의사 클래스 [04_01_실습]
[링크 의사 클래스]

* 앵커 \<a> 태그의 기본 상태 외에, 링크 방문 후 상태와 호버 상태 등의 시점에 스타일을 적용 한다. <br>

* 앵커 \<a> 태그의 기본 상태 스타일을 먼저 적용하는 것이 좋다. <br>

[동적 의사 클래스]
* 모든 엘리먼트의 클릭 상태와 호버 상태 등의 시점에 스타일을 적용 한다. <br>

* 엘리먼트의 기본 상태 스타일을 먼저 적용하는 것이 좋다. <br>

<br><br>

[각 상태 별 스타일]
    <br> **아래의 순서로 지정하지 않으면 정상적으로 작동하지 않을 수도 있다.**<br>
<br>
1) **:link** (링크 클래스) <br>
아직 선택하지 않은, href 값이 히스토리에 없는 하이퍼텍스트 링크의 모습을 선언 <br>
visted 의사 클래스 보다 항상 먼저 선언되어야 한다. <br>
*a:link { ... }*<br>

2) **:visited** (링크 클래스) <br>
이미 선택한, href 값이 히스토리에 있는 하이퍼텍스트 링크의 모습을 선언 <br>
*a:vistied { ... }*<br>

3) **:hover** (동적 클래스) <br>
마우스 포인터가 링크 위에 올라올 때 모습을 선언 <br>
마우스 상호작용 엘리먼트에만 적용 <br>
*a:hover { ... }*<br>

4) **:focus** (동적 클래스) <br>
텍스트 필드, 입력칸 처럼 포커스를 받을 수 있는 엘리먼트에 적용<br>
요소를 클릭한 상태이거나 클릭한 상태에 적용 <br>
*a:focus { ... }*<br>

5) **:active** (동적 클래스) <br>
사용자가 클릭하고 있는 순간의 모습을 선언 <br>
*a:active { ... }*<br>


<br><br>

## 3.3 구조적 및 기타 의사 클래스 [04_02_실습]
[구조적 의사 클래스]

* 부모와 각 자식 엘리트먼트 별 개별 스타일을 적용한다. <br>

* 엘리먼트에 적용된 스타일은 자식 엘리먼트에 상속된다. <br>

* 하나의 엘리먼트에 스타일이 중복되어 선언되면, 코드 상 마지막으로 선언된 스타일이 적용된다. <br>

[기타 의사 클래스]

* 언어 또는 태그 해당 여부를 기준으로 엘리먼트에 스타일을 적용한다.<br>


<br>

[각 상태 별 스타일]
<br>

1) **:root** (구조적 클래스)<br>
문서의 최상위 엘리먼트에 선언 <br>
*a:root { ... }*<br>

2) **:empty** (구조적 클래스)<br>
자식이 없는 엘리먼트에 선언 <br>
*a:empty { ... }*<br>

3) **:only-child** (구조적 클래스)<br>
형제가 없는 외동 자식 엘리먼트에 선언 <br>
*a:only-child { ... }*<br>

4) **:only-of-type** (구조적 클래스)<br>
해당 선택자 중에서 형제가 없는 외동 자식 엘리먼트에 선언 <br>
*a:only-child { ... }*<br>

5) **:first-child** (구조적 클래스) <br>
첫번째 자식에 해당되는 엘리먼트에 선언 <br>
*a:first-child { ... }*<br>

6) **:first-of-type** (구조적 클래스) <br>
해당 선택자 중에서 처음으로 해당 선택자에 속하는 엘리먼트에 선언 <br>
*a:first-of-type { ... }*<br>

7) **:nth-child(#)** (구조적 클래스) <br>
지정된 순서에 해당하는 자식 엘리먼트에 선언 <br>
*a:nth-child(3) { ... }*<br>

8) **:nth-of-type(#)** (구조적 클래스) <br>
해당 선택자 중에서 지정된 순서에 해당하는 엘리먼트에 선언 <br>
*a:nth-of-type(3) { ... }*<br>

9) **:nth-last-of-type(#)** (구조적 클래스) <br>
해당 선택자 중에서 밑에서 부터 지정된 순서에 해당하는 엘리먼트에 선언<br>
*a:nth-last-of-type(3) { ... }*<br>

10) **:last-child** (구조적 클래스) <br>
마지막 자식에 해당되는 엘리먼트에 선언<br>
*a:last-child { ... }*<br>

11) **:last-of-type** (구조적 클래스) <br>
해당 선택자 중에서 마지막으로 해당 선택자에 속하는 엘리먼트에 선언<br>
*a:last-of-type { ... }*<br>

12) **:lang()** (기타 클래스)<br>
언어 코드를 기반으로 스타일 적용<br>
*a:lang(fr) { ... }*<br>

12) **:not()** (기타 클래스)<br>
특정 선택자를 스타일 적용에서 제외<br>
*a:not(.dialog) { ... }* (클래스가 dialog 인 엘리먼트 제외)<br>

<br><br>
<br><br>
